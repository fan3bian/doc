https://blog.csdn.net/lengxiao1993/article/details/81568130
https://juejin.im/post/5a5c09d051882573282164ae

## java中的锁

#### java中的锁
在 Java 中主要2种加锁机制:
- synchronized关键字
- Lock接口
这两种机制的底层原理存在一定的差别

synchronized 关键字通过一对字节码指令 monitorenter/monitorexit 实现， 这对指令被 JVM 规范所描述。
java.util.concurrent.Lock 通过 Java 代码搭配sun.misc.Unsafe 中的本地调用实现的


jdk1.6之后，java中的锁主要分为4个状态

- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态

锁的状态会随着竞争激烈而升级（不能降级），是为了提高获取和释放锁的效率。

自旋锁：执行一段无意义的循环，使线程等待一段时间，而不是立刻挂起，看持有锁的线程是否很快的释放锁。自旋的时间(或次数)需要有个限度，超过时间后需要被挂起。自旋锁1.4.2引入，默认关闭，可以使用-xx:UseSpinning开启。jdk1.6默认开启。自旋次数可通过 -XX:preBlockSpin 来设置，默认是10
自旋锁的优点是，某些情形下，降低了线程状态切换的频率(从运行中到阻塞，从阻塞到唤醒，线程的阻塞和唤醒需要CPU从用户态转换为核心态），能够提高性能能。但某些情形下，自旋后仍然需要挂起线程，这表示自旋的过程在白白的浪费CPU，从而降低性能。

自适应自旋锁：线程自旋的次数不再是固定的，而是动态调整的。如果线程通过自旋成功了，等待到了资源的占用，下次自旋的次数会增加。如果失败了，则会减少，甚至省略自旋的过程，以免浪费处理器资源。

锁消除：JVM依据逃逸分析，检测到不存在共享资源竞争，就会对同步进行锁消除。

锁粗化：将连续多个加锁解锁操作，合并成一个范围更大的锁

