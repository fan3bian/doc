#### CAS

java线程安全问题的根源是由多线程之间通信机制导致的，线程之间通过共享变量的方式来进行通信。

锁的出现就是为了解决线程安全的问题，但是锁有一些缺点，对于共享变量的访问变成了串行化，性能较低。



synchronized加锁后，线程访问共享变量有序，串行化，效率较低。
CAS(CompareAndSet): 比较和设置。底层硬件级别的机制保证了原子性

原子类使用CAS来保证线程安全。

CAS虽然高效的解决了原子操作问题，但仍然存在三大问题： 1.**ABA问题**：如果变量V初次读取的时候值是A，后来变成了B，然后又变成了A，你本来期望的值是第一个A才会设置新值，第二个A跟期望不符合，但却也能设置新值。针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本号来保证CAS的正确性，比较两个值的引用是否一致，如果一致，才会设置新值。2.**无限循环问题（自旋）**：看源码可知，Atomic类设置值的时候会进入一个无限循环，只要不成功，就会不停的循环再次尝试。在高并发时，如果大量线程频繁修改同一个值，可能会导致大量线程执行compareAndSet()方法时需要循环N次才能设置成功，即大量线程执行一个重复的空循环（自旋），造成大量开销。解决无线循环问题可以使用java8中的LongAdder，分段CAS和自动分段迁移。 3.多变量原子问题：只能保证一个共享变量的原子操作。一般的Atomic类，只能保证一个变量的原子性，但如果是多个变量呢？可以用AtomicReference，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用AtomicReference的CAS操作可以解决并发冲突问题。 但是如果遇到ABA问题，AtomicReference就无能为力了，需要使用AtomicStampedReference来解决。


CAS的出现是解决了锁性能低的问题，但CAS也会有一些问题。

1. ABA的问题：通过AtomicStampedReference
2. 空循环的问题



- - 通过总线锁和缓存锁来保证CAS原子性。
- - 总线锁: 的概念即volatile的原理 + cpu的锁隔离
volatile当内存中变量被改变后会往总线发一个信号和将数据写回主存,其他线程读到总线的标记信号后将当前信息内的内存变量标记失效重新从共享的主存中读取最新的变量
- - cpu隔离:多核的CPU,cpu1写的时候,cpu2写不了;
-- 缓存锁:将CPU和内存之间的通信锁住了


#### Q
- CAS是如何解决ABA问题
- CAS的原子性是如何通过硬件级别保证的