## HashMap实现原理
HashMap是java语言对哈希表这种数据结构是具体实现。
HashMap的底层数据结构是数组+链表，jdk1.8以后为了优化链表中搜索元素慢的问题，引入了红黑树。


HashMap的底层数据结构是数组+链表。它支持key-value格式键值对存储，HashMap内部定义了一个类Node实现了Entry接口，用于存放键值对。有一个Node类型的成员动态数组，Node就存放在数据里面。它先是通过对Key用hash算法进行寻址运算，得到数组中的下标，定位在数组中的存储位置。如果发生了hash冲突，以链表的方式来存储hash相同的元素，1.8以后当链表的长度达到8，就会触发链表转换成红黑树，以提高遍历和修改的效率。

**哈希算法**: 获取key的hashCode，进行高低16位异或运算。
异或运算：相同的为0，不同为1。
```java
return （key == null) ? 0:(h = key.hashCode()) ^ (h >>> 16)
```
**寻址算法**：通过使用Hash算法与数组长度-1进行与运算来代替取模运算。数组的长度是2的N次方，在数组长度小于2的16次方(65536)时，高16位都是0，元素落在数组的位置也就取决于HashCode低16位的值。hash算法的高低16位进行异或运算，这样能使高16位特征也参与到元素的寻址运算中，使结果更加随机以减少Hash碰撞。

**Hash冲突**：不同的key的hashCode经过寻址运算后，


数组+链表+红黑树的。数组的长度称为容量，默认16。

链表树化条件：容量到达64，链表元素到达8


存放数据原理：通过对Key进行hash运算得到hash值，对数组长度进行取模，得到具体的下标。

```java


```

hash算法优化：key的hash值高16位和低16位进行异或运算，
寻址算法：(n-1) & hash hash值和数组长度减1进行与运算，hash异或是
hash冲突怎么解决？
数组扩容机制


从内部结构来解释用什么存放key-value键值对
Node
Node[] table
从寻址算法(hash算法)来解释具体存放在哪里

1. 回答HashMap实现原理
先说Node，然后是table，然后是hash算法和寻址算法，然后是解决hash冲突，链表和红黑树
2. hash算法和寻址算法如何进行的优化
3. hash冲突怎么解决
4. 扩容机制，hashMap是如何扩容的，如何reHash的?


