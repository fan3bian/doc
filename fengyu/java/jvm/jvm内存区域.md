## JVM内存区域
https://blog.csdn.net/ns_code/article/details/17565503
### 线程共享区域

#### Java堆
几乎所有的对象实例和数组都在Java Heap分配内存，垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

#### 方法区(Method Area)
方法区用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中

### 线程私有区域
jvm中的线程私有区域跟随线程的生命周期产生和消亡，自动的完成的内存申请和回收。

#### 虚拟机栈
该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。

栈帧中的部分信息和数据结构:
##### 1.局部变量表 
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知，

在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程。如果是实例方法（非static），则局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。
##### 2.操作数栈(Operand stack)

Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。

##### 3.动态链接
每个栈帧都包含一个指向运行时常量池（方法区中）中该栈帧所属方法的引用。常量池中存在大量的符号引用。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为**静态解析**，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。

##### 4.方法返回地址
正常退出，异常退出。论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。栈帧中的方法返回地址，用于帮助恢复上层的执行状态。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。


#### 本地方法栈 Native Method
本地方法栈则为使用到的本地操作系统（Native）方法服务。

#### 程序计数器 Programmer Counter
每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。

#### 内存溢出
内存溢出是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。
#### 内存泄漏
内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们new了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露，





