1. 
HashMap内部结构是数组+链表，1.8之后引入了红黑树。数组是一个长度为2的N次方的变长数组，用于存放元素。当执行put操作的时候，通过寻址算法对key运算得到存放数组的位置。寻址算法是通过key的hashCode的高低16位进行异或运算然后与数组的长度减一进行与运算，效果和对数组的长度取模是相同的。获取到元素在数组中的下标后，如果那个位置是空，就把元素放在这个位置上。如果有已经有元素了，比较key是否相等，相等的话就覆盖掉，不相等的话就表示发生了hash冲突，以链表的形式的来解决hash冲突。如果链表的长度达到8，且数组的长度不小于64，就会进行数组的扩容。

扩容机制：
- 扩容的情景 第一的put的时候，默认扩容到16；当元素数量超过阈值时便会触发扩容，每次扩容的容量都是之前容量的2倍；在树化的时候，数组长度是小于64，会停止树化，进行扩容

1.7和1.8区别
使用拉链法来解决hash冲突：
- 1.7使用链表 1.8在链表的基础上引入了红黑树 链表查询和插入效率是O(N)，红黑树的效率是O(logN)
- 1.7使用的链表头插法，1.8使用的是尾插法。 使用头插法优点是不用遍历整个链表；最近插入的数据，较为高效的获取到 缺点是并发情况下，resize会产生循环链。 1.8尾插入避免了循环链的问题，红黑树避免了低效率。
- 1.7进行扩容(resize)重新计算元素在数组的位置，1.8根据规律通过hash & oldCap == 0 判断是原位置还是新位置。

在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；在1.8中采用尾部插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。

为什么hash & oldCap == 0 或者 1 能够判断出是在原位置还是新位置？
因为寻址算法是hash & (cap - 1), 扩容是cap << 1,所谓扩容后要么在原位置，要么在原位置+扩容长度的新位置。所以判断再高以为是0还是1就能得出rehash后是在原位还是新位置。

为什么数组长度是2的N次方？
(1) 使用位运算替换对数组长度取模，效率更高
(2) 扩容时，不会造成大量的数据迁移。resize的时候，要么时原位置，要么时原位置+扩容长度

重写equals方法时，必须重写hashCode。HashCode时用来给Hash算法寻址的,如果值相等了但是hashCode不一致，会找不到对应的数据。

put操作流程：
- 先判断有没有初始化
- 再判断传入的key 是否为空，为空保存在table[0] 位置
- key 不为空就对key 进hash，hash 的结果高低16位异或运算，再&数组的长度-1就得到存储的位置
- 如果存储位置为空则创建节点，不为空.判断值是否相等，相等覆盖，不相等就说明存在冲突
- 解决冲突HashMap 会先遍历链表，如果有相同的value 就更新旧值，否则构建节点添加到链表头
- 添加还要先判断存储的节点数量是否达到阈值，到达阈值要进行扩容
- 扩容扩2倍，是新建数组所以要先转移节点，转移时都重新计算存储位置，可能保持不变可能为旧容量+位置。
- 扩容结束后新插入的元素也得再hash 一遍才能插入。

拓展二：HashMap 是浅拷贝，说一说浅拷贝和深拷贝的区别
拓展三：说一说Collections.synchronizedMap()和HashTable 的区别
拓展四：说一说HashMap 如何实现有序(LinkHashMap 和TreeMap)以及他们的差别
拓展五：说一说ConcurrentHashMap 如何实现线程安全

2. concurrentMap通过synchronized + CAS实现线程安全
对数组元素的头节点就行进行synchronized,通过Unsafe.compareAndSwapObejct更改。
对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。

使用volatitle修饰数组，保证get操作的内存可见性。Node节点key和hash使用final修饰，不会变更。Value和next使用volatile修饰，能保证可见性。
对于Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证

jdk1.7 使用segment分段锁的方式实现，Segment继承ReentrantLock，所以具有锁的功能。ConcurrentHashMap里维护了一个segment数组，

3. Collections.synchonizedMap()和ConcurrentHashMap
这两种方式都能保证线程安全，synchonizedMap对传入的hashMap进行了一层封装，内部的防范都是使用synchronzied进行加锁，性能低。相比较而言ConcurrentHashMap锁的粒度更小，并发性能更好。


#### 多线程
1. 进程和线程之间的区别？
进程和线程都是独立的执行序列，进程有独立的内存空间，同一个进行的多个线程之间共享进程的内存空间。

2. 为什么要使用线程池？
- 增加线程可管理性，线程是稀缺资源，不可能无限制的创建
- 降低资源的消耗，线程的频繁创建和销毁，会损耗系统性能
- 提高相应速度，任务到达时，不用等待线程创建。

3. 线程池的核心参数
executorService.

- coolPoolSize 核心线程数
- maxPoolSize 最大线程数
- timeOut 超时时间
- timeUnit 时间单位
- workQueue 工作队列
- errorHandler 失败处理器





