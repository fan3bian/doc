1. 通常而言，互联网公司面试(Java)分多轮面。
第一面技术面试，考察基本知识，确定你的能力和技术方向与职位能够匹配，第一面的目的是做筛选。
第二面技术面试，由架构师(或技术专家)担任，对你能力深度进行摸底，考察你的知识能力的宽度和广度，一般这个环节定级。
第三面管理面试，由部门领导对面试者经历和其他方面(管理、交流、态度)进行考察，领导的观感还是挺重要的。
第四面HR面试，大厂里HR的权利比较大，他们会多渠道了解你这个人，不要小看HR。

招聘一个优秀的符合岗位的人比较困难，辞退到一个能力不行的人代价也很大。大厂的面试题力求能够全面考察一个人的能力，所以方方面面的问题都会涉及。

java基础：java集合类、java多线程、java IO、JVM
Spring框架：Spring IOC和Aop、 Spring Boot自动装配、Spring Boot集成三方中间件
计算机网络原理：TCP/IP模型 Http/Https 
关系型数据库：Mysql
缓存数据库：Redis
分布式搜素引擎：Elastic Search
微服务：Dubbo ZooKeeper


1. ZooKeeper用哪些使用场景？
分布式协调系统 分布式锁 


分布式锁用什么实现？
###### redis实现分布式锁
Redis和Zookeeper
RedLock:Redis Distributed Lock 

如何保证分布式锁的有效性和安全性？

- 互斥：同一时间只能有个一个客户端获取锁
- 死锁释放：锁定资源的服务崩溃或分区，锁也能释放
- 容错性：只要一般以上的redis节点，客户端就能获取和释放锁

set key value NX EX 10000

redis通过setNx来实现互斥，通过key的有效时间(TTL或者expire)来解决死锁问题，死锁如果应用服务setKey之后，没有执行释放锁命令就宕机了，这是就造成了死锁。

锁定释放：释放前，通过lua脚本比较设置的value是否一致，一致方可删除。为了避免expire设置太短，程序执行时长超过expire，redis过期自动删除。其他的服务又设置了相同的key，导致删了其他服务设置的key。
```sh
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
方案的缺点：单机可能出现单点故障，主从架构的话，主从之间数据是异步推送，如果key还没有同步到slave节点，master节点故障，这种情况下，分布式锁是会失效的。

RedLock算法 redis集群模式
1) 获取当前时间戳，单位毫秒
2) 轮流对每个master节点创建锁，过期时间较短，半数以上成功(n/2 + 1)认为成功，规避单个redis节点故障
3) 如果创建失败了，依次删除这个锁

方案比较复杂，很难使用。


###### 基于zooKeeper实现分布式锁
通过客户端向zookeeper请求创建临时节点，创建成功代表获取到了锁；其他客户端创建会失败，然后注册这个临时节点的监听器。释放锁对应的操作就是删除这个临时节点，该临时节点一旦删除，其他客户端就会收到消息，重新加锁。


