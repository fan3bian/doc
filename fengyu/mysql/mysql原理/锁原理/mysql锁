## mysql锁

mysql锁的按照粒度划分：行级锁、页级锁、表锁
共享锁和独占锁(排他锁): 独占锁是互斥锁，独占锁与独占锁互斥，独占锁与共享锁互斥，共享锁与共享锁不互斥。
乐观锁和悲观锁


DBMS中的并发控制任务：确保多个事务同事存取同一记录时，不破坏是事务的隔离性、统一性和数据库的统一性。

#### 共享与独占

多个事务并发更新数据时，会(在行级别)加独占锁，这就是行锁，独占的锁互斥，故而可避免脏写问题。

查询时默认是不加锁的，会使用MVCC机制中的快照版本来读取。可以使用`select * from table lock in share mode`主动对一行数据加共享锁。

查询操作也可以使用独占锁`select * from table for update`

生产环境中，一般不会在数据库层面做复杂的手动枷锁操作，反而会基于redis/zookeekper分布式锁来控制业务系统锁逻辑(分布式锁)

#### 行级锁

InnoDB更新数据时，使用的是行锁。

#### 元数据锁
执行DDL(alter table)时，会阻塞所有增删改数据。执行增删改操作时，会阻塞DDL操作。这是通过Metadata Locks实现的。


#### 表级锁

1. 表锁 

表锁非常鸡肋，一般用不到。

```SQL
LOCK TABLES XXX READ; -- 表级共享锁
LOCK TABLES XXX WIRTE; -- 表级独占锁
```

2. 表级意向锁

如果事务在表里执行增删改操作，会在行级别加独占锁，同时在表级加一个意向独占锁；如果事务执行查询操作，会在表级别增加一个意向共享锁。
意向锁之间并不互斥，但意向锁会和表级的共享锁和独占锁产生一定的互斥。






